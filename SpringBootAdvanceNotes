
https://github.com/eazybytes/microservices
PDF need for revision
quesiton:
ENtity vs DTO.
DTO-https://martinfowler.com/eaaCatalog/dataTransferObject.html
Auditing and transacitons in spring data jpa:-
https://medium.com/@lavishj77/spring-data-jpa-auditing-and-transaction-management-b9e3246c2968
Documentation of Rest api:-we need add dependency of springdoc-openapi and it will add the swagger 
document of our apis through swagger endpoint and we can add more details using annotation from this dependencies.
                            -:Strangler pattern for microservice migration:-
https://www.geeksforgeeks.org/system-design/strangler-pattern-in-micro-services-system-design/

                                                          ----Docker ------
when we are using cloud services, cloud service providers have their physical infar at their data centers called servers but those are huge infra so, they can
not be given to single org .so, with help of Hypervisior concept they divide the servers resouces like ram, memory etc viutually into different parts called virtual
Matchine(VM), these vms are work as computer having memomory,os etc, so, we can use these vms according to our need of our application .
->Suppose we want to run our one of the microservices to the vm so, we need to install java version needed, data base and other dependencies so,we can run our serivce but
there is one issue with it,its not sure that our service will need all the resouces of the vm , in that case it will do the over price and for n number of services
we need to have same number of vm which is not a good practice. neither we can deploye all our services to same vm , that might cause resouces issue, dependencies issue
like java version,diff db etc.similerly scaling will be required manual intervention so, this way vm are not right for our microservices.

  VM
vm(os,libranry etc)
Hypervisior
Servers

solution of this problem is Container->its name suggest it contains all the required dependencies for particular service(simile ship container contains all needed resouces
in it for like aaple container will have ac in it)

COntainers
container1(lib,dependecies)
container engine(Docker)
Host OS
Servers

=>Even os is not there in container so,its light weight  and its super quick to restart  and destroy.
->WE will create image of our container which will be representation of our container, we can create any no of container from image like any no of obj we can create from
java class.
->Docker container is running repsentation of running image.

Follow notes from -file:///C:/Users/abhijeetkumar5/Desktop/LearningNotes-main/Learning/java%20interview%20questions/Advance%20spring%20boot/Master+Microservices+with+SpringBoot,Docker,Kubernetes.pdf


                                                                      Redis
download and unzip and start server, it will ready for accpeting traffic.
:-https://github.com/microsoftarchive/redis/releases/tag/win-3.2.100
Redis (which stands for REmote DIctionary Server) is an open-source, in-memory data structure store that is used as a database, cache, and message broker. 
Because all data resides in main memory (RAM), it delivers extremely high performance with sub-millisecond latency. 
=>https://github.com/Java-Techie-jt/spring-data-redis/tree/main =>Redis as in memory db
                                                      Redis for caching
https://github.com/Java-Techie-jt/spring-data-redis-cache
when  @GetMapping("/{id}")
    @Cacheable(key = "#id",value = "product") added at the method of serive or controller layer, first search take the data from db but next it took it from cache,
we find diff in time of response in the postman along with log of calling db is not there when we hit sencond timee.
 @Cacheable(key = "#id",value = "product") //Id is the key of cache and value is the hash of cachedb.

=>@GetMapping("/{id}")
    @Cacheable(key = "#id",value = "product",unless = "#result.price>1000") //here product will be cache based on condition if price is less than 1000 only.
=>When we are deleting the data from db, we will have remove that data from cache too, here we do so:-

@DeleteMapping("/{id}")
    @CacheEvict(key="#id",value = "product")// key and value would same as we using in cacheable. it will remove the data from cache.
 @CachePut(value = "users", key = "#user.id")=> THis will update the the data to cache when we add new data to user.

-----------------------------------------------------------------------Creating image of our application using docker-------------------------------------
First we have to mention the packing of our application in pom.xml file at place where name and verion of applicaiton is mentioned.
===>> <packaging>jar</packaging>
=>Before we make code changes for docker, when we build the application, we will getting the jar craeted for our app, which will have all code and lib but not java runtime
this is also called fat jar having big sizw e.g- accounts-0.0.1-SNAPSHOT.jar
This is created with ref of name from pom:-
<artifactId>accounts</artifactId>
<version>0.0.1-SNAPSHOT</version>
=>mvn spring-boot:run ---->Runnnig from cmd.
=>java -jar target/accounts-0.0.1-SNAPSHOT.jar ------------------->run spring boot using java
--------------------------------------------------------Creating Docker file --------------------
#Start with a base image containing Java runtime:tag like version of jdk image.Java is need for our application to run so, we are using java image which is there at dockerhub.
FROM openjdk:21-jdk-slim

# MAINTAINER instruction is deprecated in favor of using label
# MAINTAINER eazybytes.com
#Information around who maintains the image
LABEL "org.opencontainers.image.authors"="eazybytes.com"

# Add the application's jar to the image
//here we are copying our jar file from target folder which is generated post build to image(which has java and now our applicaiton is there with)

COPY target/accounts-0.0.1-SNAPSHOT.jar accounts-0.0.1-SNAPSHOT.jar

# execute the application, this is the same cmd which we used to run our app using java cmd , there was space in bwn but here commona
ENTRYPOINT ["java", "-jar", "accounts-0.0.1-SNAPSHOT.jar"]


--------------------------------------------------------------------Running docke image-------------------------------------------
First check if docker is running in our system, cmd:- docker version
=>Build docker image: ->docker build . -t easybyte/accounts:s4
format:-docker build path -t(tag) userId/nameOfapp:tag(version)
->When we build it from cmd, first it will download the openjdk from dockerhub and try to make the image by copying our jar file and jdk to it.
------------------------------------------------Running docker containere---------------
docker run -p 8080:8080 ak608333319/accounts:s4 :--p(port fisrt port is for our local system, second port is for docker to expose at 8080 , since docker run on 
isolated network, we can run same image on same port multiple at same time since, they are isolated so, every private network can run on same)
docker run -d -p 8080:8080 ak608333319/accounts:s4 //-d means runnig in detach mode so, other cmd can be fired form cmd while one is running
docker run -d -p 8081:8080 ak608333319/accounts:s4

Above two containers are runnig same image but on diff port  , so we have scaled the our app to two pod here.
We are using same port number for docker to expose for two diff pod is mained by docker call Port mapping .

`````````````````````````````````````````````````````````Buildpacks--------------
Buildpacks are a technology that automates the process of turning application source code into runnable container images, typically without the need for a Dockerfile.
They achieve this by automatically detecting the programming language and framework of an application, installing necessary dependencies,
and configuring the runtime environment.

we will add jar packing to the pom file:-
<packaging>jar</packaging>

we will add the image tag to the plugin section of the pom file:-

                 <configuration>
                    <image>
                        <name>eazybytes/${project.artifactId}:s4</name>
                    </image>
                </configuration>

=>Run the build cmd which will scan the whole project and build the image using all dependencies and we do not have to write the insturction to include
java veresion copy the  fat jar from tartet to our image etc.
=>This is required to run the docker in background.
=>mvn spring-boot:build-image  //Generating docker image form mvn.
==>RUnning the new image generated:-
docker images =>get the list of image
=>docker run -d -p 8090:9090 eazybytes/loans:s4 =>run the image with its name.
we will able to see image is running  on docker , we can hit the api from postman to validate too.

-------------------------------------------------------------------------Pushing docker image to DockerHub-----------

docker images
docker image push docker.io/ak608333319/accounts:s4 

//this will push the image like same we does in github, here we have already login from our account in docker desktop
so, cread will be taken from there and our image will be pushed to hub without explicity asked for creds.

we can see this in reps:-https://hub.docker.com/repository/docker/ak608333319/accounts/general

Anyone want to use this they can pull it:-docker pull ak608333319/accounts:s4
=>First delete the accounts container and image then we will try to pull the image from hub and run it.
