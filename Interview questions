package org.example;


import javax.swing.text.html.parser.Entity;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;


public class Main {
    public static void main(String[] args) {

        HashSet<Student> studentList = new HashSet<>();

        Student st1 = new Student("Nimit", 1);

        Student st2 = new Student("Rahul", 3);

        Student st3 = new Student("Nimit", 2);

        studentList.add(st1);

        studentList.add(st2);

        studentList.add(st3);

        System.out.println(studentList.size());

        st1.id = 2;

        System.out.println(studentList.size());
        for(Student s:studentList){
            System.out.println(s);
        }




    }
}
class Student {

    public int id;

    public String name;

    public Student(String name, int id) {

        this.name = name;

        this.id = id;

    }

    public int hashCode() {

        return this.id;

    }

    public String toString() {

        return "Student: " + this.name + "@" + Integer.toHexString(hashCode());

    }

    public boolean equals(Object o) {

        if (o instanceof Student) {

            Student s = (Student) o;

            return s.id == this.id ? true : false;

        }

        return false;

    }

}



What will be the output?  //3
Identity Crisis: You now have two objects in the Set (st1 and st3) that are "equal" according to your .equals() method. This violates the fundamental rule of a Set (no duplicates).
Memory Leaks/Bugs: If you tried to call studentList.remove(st1) after changing the ID, it might fail. The Set would look for st1 in bucket #2 (its new hash), but st1 is still physically sitting in bucket #1.
Best Practice: Always use immutable fields (like final int id) for fields used in hashCode(). If an object's state changes while it is inside a HashSet or HashMap, the collection becomes corrupted.


FInd the max length string:-


System.out.println(Arrays.asList("java", "springboot", "microservices").stream()
                .collect(Collectors.toMap(x->x,x->x.length())).entrySet().
                stream().max(Comparator.comparing(Map.Entry::getValue)).get().getKey());


FInd the output of program:-
class A {
public static void m1() {
System.out.println("A m1()");
}
 }

class B extends A {

@Override
public static void m1() {
System.out.println("B m1()");
}
 }

class MainDemo {
public static void main(String[] args) {
// A a = null; //even if it is null, it will call the A class m1
A a = New B();  //since, its static method ,it will be treat at A.m1()
a.m1();
} }

Ques:
public static void main(String[] args) {
String s1= "sanjay"; 
String s2= "jain"; 
String s3= "sanjayjain" 
s1 = s1.concat(s2); 
sout(s1==s3); //false since, the ref are diff but content are same.
}


public class A{ 

public Integer print() throws Exeption{
 System.out.println("Running class A print()");
 return 5;
 } }


 public class B extends A{ 

public Number print() throws Exeption{     //Number class is the parent class of Int values, so it can not be narrow down the return type. compilation issue
System.out.println("Running class B print()");
 return 5;
 } }

 A obj = new B(); 
0bj.print();

}

//Find the name of student with sum of their marks:-

import java.util.*;
import java.util.stream.Collectors;

class Student {
    private String name;
    private List<Integer> marks;

    public Student(String name, List<Integer> marks) {
        this.name = name;
        this.marks = marks;
    }

    public String getName() {
        return name;
    }

    public List<Integer> getMarks() {
        return marks;
    }
}

class Main {
      public static void main(String[] args) {
        // Step 1: Create a list of students
        List<Student> students = Arrays.asList(
                new Student("Amit", Arrays.asList(80, 90, 70)),
                new Student("Neha", Arrays.asList(75, 85, 95)),
                new Student("Rahul", Arrays.asList(60, 70, 80))
        );

       // Start writing your solution
 // Start writing your solution
        Map<String,Integer> studntsMarks=students.stream().
                collect(Collectors.toMap(Student::getName, x->x.getMarks().stream().mapToInt(Integer::intValue).sum()));
                        studntsMarks.forEach((k,v)->{System.out.println(k+":"+v);});

       
    }
}
 
//Print the anagram as group like word with c,a,t-[cat,ate] ect.

String[] strArr = new String[] {"eat", "ate", "cat", "elbow", "below", "tea"};
            //[cat]
        //[eat, ate, tea]
        //[elbow, below] output
            List<List<String>> list=anagram(strArr);
            list.stream().forEach(System.out::println);
        Map<String,List<String>> ans=Arrays.stream(strArr).collect(Collectors.groupingBy(
                str->{
                    char[] strArr1=str.toCharArray();
                    Arrays.sort(strArr1);
                    return new String(strArr1);

                }
        ));
        ans.entrySet().stream().map(Map.Entry::getValue).forEach(System.out::println);


type of isolation in sql
acid
solid desigh, lsp vs interface seg
concurrent 
spy
@beforeEach vs @BEforeall
ACID
encapulation->example, if one clss have private field with public setter and getter, other have public method with public filed , what is the
diff btw them
->deadlock, when this happens->realtime example->how to avoid
->executor framework
->if we have student class having roll and name, wanted to add it into the hash map as key and 100 as value , will it work ?
->implementation of HashMap
->abstraction , how do we achive this
->meory and date in java8
->Optional and Option.of(),optional.Nullable
->exception types


---------------------------------Naggaro mock ------
Goup the stirng in length and mark list its occurance.
List<String> ls=Arrays.asList("cat","dog","fox","all","zebra","apple","red","yes","no");
		ls.stream().collect(Collectors.groupingBy(String::length,Collectors.counting()))
		.forEach((x,y)->{
		    System.out.println("Length :" +x+ " "+"Count of this length: "+y);

		});




-----------------accolite second round-------

How does prototype bean work internally
how transaction work internally in spring boot
how does autoconfiguration work internally
executor->when to use 
forklift exeecurot and other
->diff between prototype and req bean, who manages this bean
->how does spring boot internally load all the claseess, if this laod all classes it would over the heap.
->internal working of @Repository,@service  how does it diff from each other.
->How atomic work interally in multithreading
->Design pattern used by Transaction in spring boot(jpa)
->proxy in spring boot
->AOP in spring boot
->is terminal operation is mandatory in stream api
->what if we don't give terminal operation and end with intermediate operation.
->when we add dependencies to our application, how does spring internally create beans and laod its classes and made the connection with asked dependencies.
->what will happen when we will make the child overriding method to protected from public , why does it not allowed narrowing of visibility.
