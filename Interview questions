package org.example;


import javax.swing.text.html.parser.Entity;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;


public class Main {
    public static void main(String[] args) {

        HashSet<Student> studentList = new HashSet<>();

        Student st1 = new Student("Nimit", 1);

        Student st2 = new Student("Rahul", 3);

        Student st3 = new Student("Nimit", 2);

        studentList.add(st1);

        studentList.add(st2);

        studentList.add(st3);

        System.out.println(studentList.size());

        st1.id = 2;

        System.out.println(studentList.size());
        for(Student s:studentList){
            System.out.println(s);
        }




    }
}
class Student {

    public int id;

    public String name;

    public Student(String name, int id) {

        this.name = name;

        this.id = id;

    }

    public int hashCode() {

        return this.id;

    }

    public String toString() {

        return "Student: " + this.name + "@" + Integer.toHexString(hashCode());

    }

    public boolean equals(Object o) {

        if (o instanceof Student) {

            Student s = (Student) o;

            return s.id == this.id ? true : false;

        }

        return false;

    }

}



What will be the output?  //3
Identity Crisis: You now have two objects in the Set (st1 and st3) that are "equal" according to your .equals() method. This violates the fundamental rule of a Set (no duplicates).
Memory Leaks/Bugs: If you tried to call studentList.remove(st1) after changing the ID, it might fail. The Set would look for st1 in bucket #2 (its new hash), but st1 is still physically sitting in bucket #1.
Best Practice: Always use immutable fields (like final int id) for fields used in hashCode(). If an object's state changes while it is inside a HashSet or HashMap, the collection becomes corrupted.


FInd the max length string:-


System.out.println(Arrays.asList("java", "springboot", "microservices").stream()
                .collect(Collectors.toMap(x->x,x->x.length())).entrySet().
                stream().max(Comparator.comparing(Map.Entry::getValue)).get().getKey());


FInd the output of program:-
class A {
public static void m1() {
System.out.println("A m1()");
}
 }

class B extends A {

@Override
public static void m1() {
System.out.println("B m1()");
}
 }

class MainDemo {
public static void main(String[] args) {
// A a = null; //even if it is null, it will call the A class m1
A a = New B();  //since, its static method ,it will be treat at A.m1()
a.m1();
} }

Ques:
public static void main(String[] args) {
String s1= "sanjay"; 
String s2= "jain"; 
String s3= "sanjayjain" 
s1 = s1.concat(s2); 
sout(s1==s3); //false since, the ref are diff but content are same.
}


public class A{ 

public Integer print() throws Exeption{
 System.out.println("Running class A print()");
 return 5;
 } }


 public class B extends A{ 

public Number print() throws Exeption{     //Number class is the parent class of Int values, so it can not be narrow down the return type. compilation issue
System.out.println("Running class B print()");
 return 5;
 } }

 A obj = new B(); 
0bj.print();

}

//Find the name of student with sum of their marks:-

import java.util.*;
import java.util.stream.Collectors;

class Student {
    private String name;
    private List<Integer> marks;

    public Student(String name, List<Integer> marks) {
        this.name = name;
        this.marks = marks;
    }

    public String getName() {
        return name;
    }

    public List<Integer> getMarks() {
        return marks;
    }
}

class Main {
      public static void main(String[] args) {
        // Step 1: Create a list of students
        List<Student> students = Arrays.asList(
                new Student("Amit", Arrays.asList(80, 90, 70)),
                new Student("Neha", Arrays.asList(75, 85, 95)),
                new Student("Rahul", Arrays.asList(60, 70, 80))
        );

       // Start writing your solution
 // Start writing your solution
        Map<String,Integer> studntsMarks=students.stream().
                collect(Collectors.toMap(Student::getName, x->x.getMarks().stream().mapToInt(Integer::intValue).sum()));
                        studntsMarks.forEach((k,v)->{System.out.println(k+":"+v);});

       
    }
}
 
//Print the anagram as group like word with c,a,t-[cat,ate] ect.

String[] strArr = new String[] {"eat", "ate", "cat", "elbow", "below", "tea"};
            //[cat]
        //[eat, ate, tea]
        //[elbow, below] output
            List<List<String>> list=anagram(strArr);
            list.stream().forEach(System.out::println);
        Map<String,List<String>> ans=Arrays.stream(strArr).collect(Collectors.groupingBy(
                str->{
                    char[] strArr1=str.toCharArray();
                    Arrays.sort(strArr1);
                    return new String(strArr1);

                }
        ));
        ans.entrySet().stream().map(Map.Entry::getValue).forEach(System.out::println);


type of isolation in sql
acid
solid desigh, lsp vs interface seg
concurrent 
spy
@beforeEach vs @BEforeall
ACID
encapulation->example, if one clss have private field with public setter and getter, other have public method with public filed , what is the
diff btw them
->deadlock, when this happens->realtime example->how to avoid
->executor framework
->if we have student class having roll and name, wanted to add it into the hash map as key and 100 as value , will it work ?
->implementation of HashMap
->abstraction , how do we achive this
->meory and date in java8
->Optional and Option.of(),optional.Nullable
->exception types


---------------------------------Naggaro mock ------
Goup the stirng in length and mark list its occurance.
List<String> ls=Arrays.asList("cat","dog","fox","all","zebra","apple","red","yes","no");
		ls.stream().collect(Collectors.groupingBy(String::length,Collectors.counting()))
		.forEach((x,y)->{
		    System.out.println("Length :" +x+ " "+"Count of this length: "+y);

		});




-----------------accolite  round-------

How does prototype bean work internally
how transaction work internally in spring boot
how does autoconfiguration work internally
executor->when to use 
forklift exeecurot and other
->diff between prototype and req bean, who manages this bean
->how does spring boot internally load all the claseess, if this laod all classes it would over the heap.
->internal working of @Repository,@service  how does it diff from each other.
->How atomic work internally in multithreading
->Design pattern used by Transaction in spring boot(jpa)
->proxy in spring boot
->AOP in spring boot
->is terminal operation is mandatory in stream api
->what if we don't give terminal operation and end with intermediate operation.
->when we add dependencies to our application, how does spring internally create beans and laod its classes and made the connection with asked dependencies.
->what will happen when we will make the child overriding method to protected from public , why does it not allowed narrowing of visibility.



--------------------------

String input="aabbccccddaz";
        StringBuilder sb=new StringBuilder();
        int count=1;
        for(int i=0;i<input.length();i++){
            if(i<input.length()-1&&input.charAt(i)==input.charAt(i+1)){
                count++;

            }else{

                sb.append(input.charAt(i));
                sb.append(count);
                count=1;
            }
        }

        System.out.println(sb.toString());


{2,4,7,9,11} Input is 11 find the duplet to find the sum of two number is 11

HashMap<Integer,Integer> hs=new HashMap<>();

int sum=0;
if(hs.get(input-arr[i]){
	ans->hs.get(input-arr[i]), i;
else
   hs.put(2,i)
}



@Configuration
public class HttpClientConfig1 {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

@Configuration
public class HttpClientConfig2 {

    @Bean
    public RestTemplate restTemplate() {
        RestTemplate rt = new RestTemplate();
        // some interceptors
        return rt;
    }
}

which is best approch

boolean exists =
    employees.stream()
             .filter(e -> e.getSalary() > 100000)
             .findFirst()
             .isPresent();
boolean exists =
    employees.stream()
             .anyMatch(e -> e.getSalary() > 100000);


int arr[]={6,3,7,4,5,2};
        int target=9;



public static int  fibonacii(int n){
        if(n==1 ||n==0){
            return n;
        }else{
            return fibonacii(n-1)+fibonacii(n-2);
        }
    }


try{
 cout" print try""
return 2
}catch{

cout "print cath
return 5

}
finally{

print "finalluy
return 3;




//

try{

x=2;
return x;
finally(){
x=+2;
}


//

try{

int arr[]={1};
return 
finally(){
x=+2;
}



						----------Altimetrik------------
//Given an array of integers, find the first non-repeating element.
        // Return -1 if all elements repeat. Example Input: [9, 4, 9, 6, 7, 4] Output: 6





package org.example;
import javax.swing.text.html.parser.Entity;
import java.util.*;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.*;
import java.util.stream.Collectors;
public class Main {

    public static void main(String[] args) {
        Employee emp1=new Employee("sam",1234,new Department("HR"));
        Employee emp2=new Employee("ram",1235,new Department("HR"));
        Employee emp3=new Employee("samu",1236,new Department("IT"));
        Employee emp4=new Employee("sams",1237,new Department("IT"));
        Employee emp5=new Employee("samst",1238,new Department("HR"));
        //higest sal each department.
        List<Employee> employees=new ArrayList<>();
        employees.add(emp1);
        employees.add(emp2);
        employees.add(emp3);
        employees.add(emp4);
        employees.add(emp5);
        employees.stream()
                .collect(Collectors.groupingBy(emp->emp.getDepartment().getDepartment()))
                .entrySet().stream().
                map(x->x.getValue().stream().max(Comparator.comparingInt(Employee::getSal)).get())
                .forEach(x->System.out.println(x.name+" "+x.getSal() + " "+x.getDepartment().getDepartment()));



        Map<String, Optional<Employee>> result = employees.stream()
                .collect(Collectors.groupingBy(
                        e -> e.getDepartment().getDepartment(),
                        Collectors.maxBy(Comparator.comparingInt(Employee::getSal))
                ));
    }
}
class Employee{
    String name;
    int sal;
    Department department;
    Employee(String name, int sal, Department department){
        this.name = name;
        this.sal = sal;
        this.department = department;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getSal() {
        return sal;
    }

    public void setSal(int sal) {
        this.sal = sal;
    }

    public Department getDepartment() {
        return department;
    }

    public void setDepartment(Department department) {
        this.department = department;
    }
}
class Department{
    String department;
    Department(String department) {
        this.department = department;
    }

    public String getDepartment() {
        return department;
    }

    public void setDepartment(String department) {
        this.department = department;
    }
}




Problem 1
Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] where nums[i] + nums[j] + nums[k] == targetNumber (take  as input), and the indices i, j and k are all distinct.

The output should not contain any duplicate triplets. You may return the output and the triplets in any order.

Example 1:

Input: nums = [-1,0,1,2,-1,-4]


Target number = 3
Output: [0,1,2]

Input: arr[] = [1, 4, 45, 6, 10, 8], target = 13
Output: true
Explanation: The triplet [1, 4, 8] sums up to 13

Input: arr[] = [1, 2, 4, 3, 6, 7], target = 10 
Output: true
Explanation: The triplets [1, 3, 6] and [1, 2, 7] both sum to 10. 


HashMap<Integer,Integer> has=new HashMap<>();
for(int i=0;i<nums.length;i++){


if(has.contains(targer-nums[i]){
	print-
}else{
   has.put(nums[i],i);

}
Broker 1->partition 1

Broker 2->partition 1

}



Interface A {

	Default Method A {
		Some business logic
}	 
}

Interface B {

	Default Method A {
		Some business logic
}	 
}


Class X implements A, B {  //will it compile


}

Altimetrix client round:-
//        Input array - [1,2,4]
//        Output array - [1,2,5]
//        Input array - [1,2,9]
//        Output array - [1,3,0]



//        Output - a4b3g2k7b3
//        Input - Aaabbaa
//        Output -  - a3b2a2
//        String str="aaaabbbggkkkkkkkbbba";
//        int count=1;
//        StringBuilder sb=new StringBuilder();
//        for(int i=0;i<str.length()-1;i++){
//            if(str.charAt(i)==str.charAt(i+1)){
//                count++;
//            }else{
//                sb.append(str.charAt(i));
//                sb.append(count);
//                count=1;
//            }
//        }
//        sb.append(str.charAt(str.length()-1));
//        sb.append(count);
//        System.out.println(sb);




							Accolite fourth round
how to check why sql query is taking too much time when it is being using multiple jons, form sql .(direct ide )
->when we have 5 threads and we want to all 5 threads to get completed first then only our main thread execute
->How can i use the HashMap in multi threaded env
->how annotation work internally, how can we develop for validatation mandatory field in object
->Create signly link list
->why vertical sacling has limitation
->how to scale for high trafic
->how can we opt the garbase collector stategy and what are they
->why do we need custom exception if we can bind the message to existing exception type.
->if we are getting memory exception in trace  . what will you check to debug
