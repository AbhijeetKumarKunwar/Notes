Azure Cosmos DB is a fully managed, globally distributed, multi-model database service offered by Microsoft Azure. It is designed to provide high availability, scalability, and low-latency access to data for modern applications.
Key features of Azure Cosmos DB include:

Global Distribution:
It allows data distribution across multiple Azure regions, ensuring low-latency access for users worldwide and high availability.

Multi-Model Support:
Azure Cosmos DB natively supports various data models, including document (NoSQL), key-value, graph (Gremlin), and column-family (Cassandra), providing flexibility for different application needs.

Automatic and Instant Scalability:
It automatically scales throughput and storage based on application demands, eliminating the need for manual capacity planning.

Guaranteed Performance:
It offers guaranteed single-digit millisecond latency and high availability with financially backed SLAs.

Multiple Consistency Models:
It provides a range of consistency models (eventual, consistent prefix, session, bounded-staleness, and strong) to balance consistency and performance based on application requirements.

Serverless and Provisioned Throughput Options:
It offers both serverless and provisioned throughput capacity modes, allowing optimization for cost and performance based on workload patterns.
API IN COSMOS DB:-

Azure Cosmos DB offers multiple APIs to interact with your data, providing flexibility based on your application's needs and existing skillsets. These APIs allow you to leverage Azure Cosmos DB's global distribution, elastic scalability, and guaranteed low latency while using familiar data models and query languages.
The primary APIs available are:

NoSQL (Core) API:
This is the native API for Azure Cosmos DB, designed for document-oriented data. It supports SQL-like queries for JSON documents and is ideal for new applications or those requiring high performance and flexibility.

MongoDB API:
This API provides wire protocol compatibility with MongoDB, allowing you to use existing MongoDB drivers, SDKs, and tools with Azure Cosmos DB. It's suitable for migrating existing MongoDB applications with minimal code changes.

PostgreSQL API:
This API offers PostgreSQL compatibility, enabling you to use Azure Cosmos DB as a PostgreSQL database. It supports relational data models, SQL queries, and features like JSON support and geospatial capabilities.

Cassandra API:
This API provides compatibility with Apache Cassandra, allowing you to use Cassandra drivers and tools with Azure Cosmos DB. It's suitable for migrating existing Cassandra-based applications.

Gremlin API:
This API is designed for graph data models, allowing you to store and query data as vertices and edges using the Gremlin traversal language. It's ideal for applications requiring graph-based analysis, such as social networks or recommendation engines.

Table API:
This API provides compatibility with Azure Table Storage, offering a key-value store for high-throughput, low-latency applications. It's suitable for migrating existing Azure Table Storage applications.
=>we have to create acount for each api, one account will not work for other account api.

Why No Sql DB?
->High volume of data
->Dynamic schema {data from socia media}
->Horizental scaling
->don't force schema

DATA MODELS in NO SQL:-
There are four primary types of NoSQL data models:

Document Databases:
These store data in flexible, semi-structured documents, often in formats like JSON or BSON. Each document can have a different structure, making them well-suited for handling diverse and evolving data. Examples include MongoDB and Apache CouchDB.,cosmos db.

Key-Value Stores:
This is the simplest NoSQL model, where data is stored as a collection of key-value pairs. Each key is unique and maps to a specific value, which can be any type of data. Examples include Redis and Amazon DynamoDB.azure table.

Wide-Column Stores (Column-Family Databases):
These organize data into tables, but unlike relational databases, columns can be added dynamically, and rows can have different sets of columns. This model is optimized for handling large datasets with high read and write throughput. Examples include Apache Cassandra and HBase.

Graph Databases:
These are designed to store and query highly connected data, representing entities as "nodes" and their relationships as "edges." This model is ideal for applications involving complex relationships, such as social networks or recommendation engines. Examples include Neo4j and OrientDB.,apache gemlin

NoSQL data models are chosen for their flexibility, scalability (especially horizontal scalability), and performance in handling large volumes of diverse data, making them suitable for modern applications like big data analytics, real-time applications, and content management systems.

Why to use nosql db with document  data model ?
->json is commonly used data format
-> cosmos db supports json cosmos natively
->no need to predefine schema
->Diff type of data can be stored together.

Advantages it provides:-
Guaranteed speeed
fully managed serverless.(users do not need to provision or manage the underlying infrastructure or manually configure throughput capacity)

=>When to go for Nosql cosmos db:-
Unpredictable spike and high dip in traffic.
Applicaiton generate lots of data
Business continuty

----Component of cosmos db for no sql:--
1.Account:- A Database Account is the top-level resource, providing a unique endpoint for accessing Cosmos DB resources A Database     Account is the top-level resource, providing a unique endpoint for accessing Cosmos DB resources.
2.Database:- Databases act as namespaces, managing users and permissions.
3.COntainer:-Containers, similar to tables, store items, which can be documents, rows, or other atomic data structures, depending on the chosen AP
4.items:-data


======================================Creating azure cosmos db account for nosql======
https://portal.azure.com/#home
#########Basic####
->database->azure cosmos db->subscription tye
->Resouce group (logical group where all db will be there)
->Account Name->unique account name
->location where our appliaciton is deployed
->capacity mode->provisioned thoughput(rented resouces dedicatedly) /serverless(pay as you go autometically)
->Provisioned throughput->in case of traffic is highly predictable
->checked for limited provisioned thorught put is there to controll the pricing.

###########Global distribution########
=>Geo Redendency->DAta would replicated in other resons as Read-only mode to increase the availablity e.g as we selected the East us in region under basic, if we enabled this then it will be paired to us West too in read only mode.
=>Multi Region write:->if we enabled this data would be availble in paired region with write access,( can be written to all region)
=>Availablity zone:->Data would be replicated to all zone of selected region.

################ Network###############
we can select the all network, public , private according to ned.

##############Backup Policy #############
->periodic->we need to give the period time->backup interval (in how many hour of interval we need to take backup),->no of days
suppose it is taking backup interval of 6 hour so, it will create copy of 4 in 24 hour , if we does for 25 days , it will create
copy of 60 files.
->conineus 7 days ->free
->continues 30 days {cost} can be retrive any time  within the window.

#################### Encyption################
encyption type->service managed key OR custom managed key {encryption of data}
####################Tag##############
Key value label e.d Env :learning
-------------------account will be create the reviewing the details--------------
post creation we will get the url to access the DB.
RU=>
Request Units (RUs) are a performance currency of system resources (such as CPU, IOPS, and memory)
=>we have diff option to explore like activity log to see all log of activity,iam, etc


-----------------------------------Creating database---------
creating container is same as creating tables
when we will go to new , we will have option of new container/new Database
->new Data base->ask for databaseId(name)->if we check at provision thoughPut->we have to give the thorugput option ->
autoscale(we need to give the RU/s , first it will use 10 percent of limit and increase in the case of trafic) /Manual-> RU/s->OK to create db.
----------------------------------creating container Table------------

